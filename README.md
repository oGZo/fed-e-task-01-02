### 简单题答案
第一题
```
执行结果:   10
原因： i值随着for循环一直在递增，随着for循环结束i值达到 10 
此后， 执行数组a任一下标对应的方法 方法内部的i均为其作用域外部的i 值均为10；
```


第二题
```
执行结果：报错：  tmp is not defined

原因: let会在当前块级作用域 形成一个暂时作用域死区， 提前调用其声明的变量会报未定义错误；
```

第三题

```
const findMinFromArr = (arr) => Math.min(...arr);
```


第四题

```
let 和 const 
1. 作用域为当前块；
2. 会形成块级作用域死区， 提前使用变量会报错； 
3. 变量不会提升；

var 
1. 只有函数作用域和全局作业域
2. 可提前使用但值为 undefined

const  
1. 声明的变量不可重新赋值
```


第五题

```
结果： 20

解释： 
1. 使用obj.fn()来执行方法 那么 fn函数内部的this为 obj, 
2. setTimeout函数内使用的事箭头函数 内部this和其外部的this指向相同 故为 obj
 故 this.a  => obj.a  => 20;
```


第六题

```
主要用途: 为对象添加独一无二的值；
具体如下
1. 可防止命名空间的属性或者方法被覆盖;
2. 变量利用Symbol.iterator属性可实现 被for-of操作；
3. 实现对象的私有成员;
```

第七题
```
浅拷贝 拷贝对象第一层的值;
深拷贝 除了第一层的值 还会递归拷贝其他层级的值对象的值；
```

第八题

```
typescript 是javascript的超集

typescript = javascript + 类型系统 + es6+语法
```


第九题

```
优点
1. 完善的类型系统
2. es6+语法
3. 完善和健全的生态
缺点
1. 多了很多概念
2. 项目初期会增加一些项目成本
```

第十题

```
原理： 对变量的使用的次数计数 使用一次计数器加1否则减1， 当变量的使用的次数计数为0时  就回收该变量所占用的内存地址

优点： 1. 内存回收及时；
      2. 最大限度减少程序暂停时间；

缺点： 1. 循环引用问题无法解决；
      2. 时间开销大；

```

第十一题

```
1. 把标记好的活动对象整理到连续的内存空间中；
2. 回收非活动对象所占用的内存地址；
```


第十二题

```
答
1. 新生代空间分为两个区域from使用空间 和 to闲置空间;
2. 将活跃对象放置from区中；
3. 标记整理from空间中的对象；
4. 将from区域活动对象拷贝至to空间；
5. to区变成from区域；
6. from空间 和to空间进行交换；
7. 释放老的from空间即新的to空间；
8. 中间遇到已经处理过的对象 则将其晋升到老生代区域；
9. 如果to区域超过25%也会有部分对象呗晋升到老生代区域；
```


第十三题
答
```
时机
1. 使用时机 老生代回收区域；
2. 老生代回收工作量大的时候；
原理
将老生代特别耗时的标记任务 拆解为一个个耗时较短的标记任务，降低垃圾回收对主线程的影响， 等全部标记完成 再统一进行垃圾回收
 比如先标记第一层可达对象 完了之后，继续主线程工作， 然后再递归标记一轮，然后再进行主线程操作， 知道都标记完成再统一进行垃圾回收；

```